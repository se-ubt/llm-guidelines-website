\documentclass[11pt]{article}
\usepackage[parfill]{parskip} % use newlines for paragraphs (more similar to Markdown)

\begin{document}

\subsection{LLMs as Tools for Software Engineering Researchers}

LLMs can be leveraged as powerful tools to assist researchers conducting empirical studies.
They can automate various tasks such as data collection, preprocessing, and analysis.
For example, LLMs can apply pre-defined coding guides to large qualitative datasets (\textbf{annotation}), assess the quality of software artifacts (\textbf{rating}), generate summaries of research papers (\textbf{synthesis}), and even simulate human behavior in empirical studies (\textbf{subject}).
This can significantly reduce the time and effort required by researchers, allowing them to focus on more complex aspects of their studies.
However, all these applications also come with limitations, potential threats to validity, and implications for the reproducibility of study results.
In our guidelines, the following study types and used to contextualize the recommendations we provide.


\subsubsection{LLMs as Annotators}

\emph{Description:} LLMs can serve as annotators by automatically labeling artifacts with corresponding categories for data analysis based on a pre-defined coding guide.
In qualitative data analysis, manually annotating or coding text passages, e.g. in software artifacts, open-ended survey responses, or interview transcripts, is often a time-consuming manual process.
LLMs can be used to augment or even replace human annotations, provide suggestions for new codes (see \textbf{synthesis}), or even automate the entire process.

\emph{Example:} For example, in a study analyzing code changes in version control systems, researchers may need to categorize each individual change into predefined categories.
For that, they may use LLMs to analyze commit messages and categorize them using labels such as bug fixes, feature additions, or refactorings, based on a short description of each label.

\emph{Promises:} Recent research demonstrates several key advantages of using LLMs as annotators. 
\begin{itemize}
    \item  LLM-based annotation can dramatically reduce costs compared to human labeling, with studies showing cost reductions of 50-96\% across various natural language tasks~\cite{DBLP:conf/emnlp/WangLXZZ21}. 
    \item LLMs can achieve comparable or even superior performance to crowd workers -- for instance, ChatGPT's accuracy exceeded that of crowd workers by approximately 25\% on average across multiple annotation tasks~\cite{DBLP:journals/corr/abs-2303-15056}. 
    \item LLMs demonstrate remarkably high intercoder agreement, surpassing both crowd workers and trained annotators~\cite{DBLP:journals/corr/abs-2303-15056}. 
    \item Models trained on LLM-generated labels can sometimes outperform the LLM itself on specific classification tasks, suggesting potential for bootstrapping improved performance~\cite{DBLP:conf/emnlp/WangLXZZ21}. 
    \item LLMs can generate explanations alongside their annotations, which can help verify the quality of labels and assist humans in understanding the classification decisions~\cite{DBLP:conf/chi/Wang0RMM24}. 
    \item Lightweight classifiers trained on LLM-generated labels can achieve comparable or better performance than using LLMs directly as classifiers, while being more efficient and manageable at scale~\cite{DBLP:conf/kdd/WanSJKCNSSWYABJ24}. 
    \item Hybrid approaches combining LLM and human annotations can achieve even better results than either approach alone~\cite{DBLP:conf/emnlp/WangLXZZ21}.
\end{itemize}

\emph{Perils:} Several important challenges and limitations must also be considered. 
\begin{itemize}
    \item While LLMs can be effective annotators, their performance varies significantly across tasks and can be particularly unreliable for complex or nuanced annotations~\cite{DBLP:conf/www/HuangKA23a,DBLP:conf/chi/Wang0RMM24}. 
    \item LLMs can affect human judgment in annotation tasks -- research shows that when LLM labels are incorrect, human annotators perform worse than without any LLM assistance~\cite{DBLP:conf/www/HuangKA23a}. 
    \item LLMs tend to be overconfident in their predictions, requiring careful verification of their outputs~\cite{DBLP:conf/kdd/WanSJKCNSSWYABJ24}. 
    \item The quality of LLM-generated explanations significantly impacts human annotators' performance and satisfaction, with poor-quality explanations potentially hindering rather than helping the annotation process~\cite{DBLP:conf/chi/Wang0RMM24}
    \item While cost-effective overall, LLM annotation still incurs per-token charges that must be carefully managed, especially for longer texts~\cite{DBLP:conf/emnlp/WangLXZZ21}. 
    \item Researchers note that LLMs are not yet reliable enough for high-stakes labeling tasks, such as identifying toxic language, and are better suited for low-stakes applications~\cite{DBLP:conf/chi/Wang0RMM24}.
\end{itemize}
%In such tasks, LLMs have the potential to improve the accuracy and efficiency of automated labeling processes~\cite{DBLP:conf/kdd/WanSJKCNSSWYABJ24}, making them valuable tools for empirical research in software engineering.
%Hybrid human-LLM annotation approaches may further increase accuracy and allow for the correction of incorrectly applied labels~\cite{DBLP:conf/chi/Wang0RMM24}.

\emph{Previous Work in SE:} Recent work in software engineering has begun exploring the use of LLMs for annotation tasks. 
Ahmed et al.~\cite{DBLP:journals/corr/abs-2408-05534} conducted a comprehensive study evaluating whether LLMs could replace human annotators for software engineering artifacts.
Their findings demonstrated that LLMs performed particularly well on name-value inconsistency detection and semantic similarity tasks, achieving human-comparable inter-rater agreement levels. 
However, they found LLMs struggled significantly with causality detection and static analysis warning classification, where human-model agreement was much lower than human-human agreement. 
For code summarization tasks, LLMs showed moderate success but still fell short of human performance. 
Based on these results, they recommend using LLMs to replace only one human rater rather than the entire annotation team, as model-model agreement strongly correlates with human-model agreement.

Colavito et al.~\cite{DBLP:conf/msr/ColavitoLNQ24} investigated the potential of GPT-like models for automated issue labeling in software repositories. 
Their study compared different prompting strategies (zero-shot and few-shot) using various versions of GPT-3.5 models with different context lengths. 
Their results demonstrated that GPT-like models could achieve performance comparable to state-of-the-art BERT-like models without requiring fine-tuning. 
In particular, GPT-3.5 achieved an F1-micro score of 0.8155 using only zero-shot learning (without any training data), which was close to the 0.8321 F1-micro score achieved by the SETFIT baseline model (Sentence Transformer Fine-Tuning, a framework optimized for fine-tuning transformer models on small datasets), despite SETFIT requiring fine-tuning on labeled training data.
Notably, they observed substantial agreement between GPT-3.5 and human annotators (Cohen's $\kappa > 0.7$) across different experimental settings, suggesting that these models could effectively support human annotation efforts in creating gold-standard datasets.

Huang et al.~\cite{Huang2023Enhancing} proposed an approach leveraging multiple LLMs for joint annotation of mobile application reviews. 
Their Multi-model Joint Annotation Reviews (MJAR) dataset construction method used three 7B-parameter models (Llama3, Gemma, and Mistral) with an absolute majority voting rule (i.e., a label is only accepted if it receives more than half of the total votes from the models). 
Accordingly, the annotations fell into three categories: exact matches (where all models agreed), partial matches (where a majority agreed), and non-matches (where no majority was reached). 
The authors evaluated the quality of these annotations by training BERT and RoBERTa classifiers on different training sets. 
When trained on the MJAR dataset, BERT achieved an F1 score of 78.62\% and accuracy of 80.36\%. 
In comparison, BERT's performance was lower when trained on data annotated by single models: Mistral annotations led to an F1 score of 72.56\%, Gemma to 75.84\%, and Llama3 to 77.48\%.
RoBERTa showed similar improvements when trained on the MJAR dataset, as compared to single-model annotations, with a 1.73\% increase in F1 score.

Wang et al.~\cite{DBLP:conf/chi/Wang0RMM24} developed a human-LLM collaborative annotation framework with a novel verification component. 
The verifier is a Random Forest classifier trained on three types of features: characteristics of the input sample (such as text coherence and readability), LLM output features (including logits and probability scores), and features from LLM-generated explanations (including their coherence and sufficiency); the verifier then assigns confidence scores to LLM annotations, allowing the framework to identify which samples need human review. 
Their empirical evaluation found a moderate positive correlation between model-to-model agreement and human-model agreement (Spearman $\rho = 0.65$), suggesting that model agreement could be one useful indicator for when to trust LLM annotations.
Using this approach, they demonstrated that up to 50-100\% of annotations for certain tasks could be delegated to LLMs while maintaining quality comparable to human annotation. 
The system was particularly effective when LLMs showed high confidence in their predictions, though performance varied by task type.

These studies suggest that while LLMs show promise as annotation tools in SE, their optimal use may be in augmenting rather than replacing human annotators entirely, with careful consideration given to verification mechanisms and confidence thresholds.

\subsubsection{LLMs as Raters}

\emph{Description:} In empirical studies, LLMs can act as raters to evaluate the quality or other properties of software artifacts such as code, documentation, and design patterns.

\emph{Example:}  For instance, LLMs can be trained to assess code readability, adherence to coding standards, or the quality of comments. 

\emph{Promises:} By providing---depending on the model configuration---consistent and relatively ``objective'' evaluations, LLMs can help mitigate certain biases and part of the variability that human raters might introduce. 
This can lead to more reliable and reproducible results in empirical studies.

\emph{Perils:} However, when relying on the judgment of LLMs, researchers have to make sure to build a reliable process for generating ratings that considers the non-deterministic nature of LLMs and report the intricacies of that process transparently.

\emph{Previous Work in SE:}  \textbf{TODO:} Examples of such studies in software engineering include...


\subsubsection{LLMs for Synthesis}

\emph{Description:} LLMs can be used to synthesis large amounts of qualitative data.

\emph{Example:}  For example, they can summarize or compare papers for literature reviews or support researchers in deriving codes and developing coding guides during the initial phase of qualitative data analysis. Those code can then later be used to annotate more data (see \textbf{annotation}).

\emph{Promises:} \textbf{TODO}

\emph{Perils:} \textbf{TODO}

\emph{Previous Work in SE:}  \textbf{TODO:}  \textbf{TODO:} Examples of such studies in software engineering include...


\subsubsection{LLMs as Subjects}

\emph{Description:} LLMs can be used as subjects in empirical studies to simulate human behavior and interactions.

\emph{Example:} For example, researchers can use LLMs to generate responses in user studies, simulate developer interactions in collaborative coding environments, or model user feedback in software usability studies.

\emph{Promises:}  This approach can provide valuable insights while reducing the need to recruit human participants, which can be time-consuming and costly. Additionally, using LLMs as subjects allows for controlled experiments with consistent and repeatable conditions.

\emph{Perils:} However, it is important that researchers are aware of LLMs' inherent biases~\cite{Crowell2023} and limitations~\cite{DBLP:journals/ais/HardingDLL24} when using them as study subjects.

\emph{Previous Work in SE:}  \textbf{TODO:}  \textbf{TODO:} Examples of such studies in software engineering include...

\subsubsection{References}

\bibliographystyle{plain}
\bibliography{../../literature.bib}

\end{document}
